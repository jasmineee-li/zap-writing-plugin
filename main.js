/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => DangerousWritingPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian4 = require("obsidian");

// settings.ts
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  sessionDurationMinutes: 5,
  defaultWordCountGoal: 0,
  // 0 means disabled, use duration instead
  idleTimeoutSeconds: 5,
  practiceMode: true,
  warningThresholdSeconds: 3,
  showFirstTimeWarning: true,
  penaltyType: "all",
  warningColor: "#ff0000"
};
var DangerousWritingSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  createStatCard(container, label, value) {
    const card = container.createEl("div", { cls: "dangerous-writing-stat-card" });
    card.createEl("div", { text: value, cls: "stat-value" });
    card.createEl("div", { text: label, cls: "stat-label" });
  }
  formatDuration(seconds) {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor(seconds % 3600 / 60);
    const secs = seconds % 60;
    if (hours > 0) {
      return `${hours}h ${minutes}m`;
    } else if (minutes > 0) {
      return `${minutes}m ${secs}s`;
    } else {
      return `${secs}s`;
    }
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Dangerous Writing Settings" });
    new import_obsidian.Setting(containerEl).setName("Default session duration (minutes)").setDesc("Default duration for writing sessions (can be overridden when starting a session)").addText((text) => text.setPlaceholder("5").setValue(this.plugin.settings.sessionDurationMinutes.toString()).onChange(async (value) => {
      const num = parseInt(value) || 5;
      if (num > 0 && num <= 1440) {
        this.plugin.settings.sessionDurationMinutes = num;
        await this.plugin.saveSettings();
      }
    }));
    new import_obsidian.Setting(containerEl).setName("Default word count goal").setDesc("Default word count goal (0 = disabled, use duration instead)").addText((text) => text.setPlaceholder("0").setValue(this.plugin.settings.defaultWordCountGoal.toString()).onChange(async (value) => {
      const num = parseInt(value) || 0;
      if (num >= 0 && num <= 1e5) {
        this.plugin.settings.defaultWordCountGoal = num;
        await this.plugin.saveSettings();
      }
    }));
    const idleTimeoutSetting = new import_obsidian.Setting(containerEl).setName("Idle timeout (seconds)").setDesc("How long you can stop typing before the penalty triggers").addText((text) => text.setPlaceholder("5").setValue(this.plugin.settings.idleTimeoutSeconds.toString()).onChange(async (value) => {
      const num = parseInt(value) || 5;
      if (num > 0 && num <= 300) {
        this.plugin.settings.idleTimeoutSeconds = num;
        if (this.plugin.settings.warningThresholdSeconds > num) {
          this.plugin.settings.warningThresholdSeconds = num;
        }
        await this.plugin.saveSettings();
        this.display();
      }
    }));
    new import_obsidian.Setting(containerEl).setName("Penalty type").setDesc("What gets deleted when you stop typing").addDropdown((dropdown) => dropdown.addOption("all", "Delete entire file").addOption("paragraph", "Delete last paragraph").addOption("sentence", "Delete last sentence").setValue(this.plugin.settings.penaltyType).onChange(async (value) => {
      this.plugin.settings.penaltyType = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Practice mode").setDesc("When enabled, you can recover content after a penalty. Disable for the real dangerous experience!").addToggle((toggle) => toggle.setValue(this.plugin.settings.practiceMode).onChange(async (value) => {
      this.plugin.settings.practiceMode = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Warning threshold (seconds)").setDesc(`When to start showing visual warnings before idle timeout (max: ${this.plugin.settings.idleTimeoutSeconds}s)`).addText((text) => text.setPlaceholder("3").setValue(this.plugin.settings.warningThresholdSeconds.toString()).onChange(async (value) => {
      const num = parseInt(value) || 3;
      const max = this.plugin.settings.idleTimeoutSeconds;
      if (num > 0 && num <= max) {
        this.plugin.settings.warningThresholdSeconds = num;
        await this.plugin.saveSettings();
      } else if (num > max) {
        this.plugin.settings.warningThresholdSeconds = max;
        text.setValue(max.toString());
        await this.plugin.saveSettings();
      }
    }));
    new import_obsidian.Setting(containerEl).setName("Warning color").setDesc("Color of the warning overlay when idle time approaches").addColorPicker((color) => color.setValue(this.plugin.settings.warningColor).onChange(async (value) => {
      this.plugin.settings.warningColor = value;
      await this.plugin.saveSettings();
      this.plugin.updateWarningStyles();
    }));
    containerEl.createEl("h2", { text: "Statistics" });
    const sessions = this.plugin.sessions || [];
    const now = Date.now();
    const day = 24 * 60 * 60 * 1e3;
    const week = 7 * day;
    const month = 30 * day;
    const todaySessions = sessions.filter((s) => s.timestamp >= now - day);
    const weekSessions = sessions.filter((s) => s.timestamp >= now - week);
    const monthSessions = sessions.filter((s) => s.timestamp >= now - month);
    const totalSessions = sessions.length;
    const completedSessions = sessions.filter((s) => s.completed).length;
    const totalWords = sessions.reduce((sum, s) => sum + s.wordsWritten, 0);
    const totalTime = sessions.reduce((sum, s) => sum + s.durationSeconds, 0);
    const statsContainer = containerEl.createDiv({ cls: "dangerous-writing-basic-stats" });
    if (totalSessions > 0) {
      const statsGrid = statsContainer.createDiv({ cls: "dangerous-writing-stats-grid" });
      this.createStatCard(statsGrid, "Total Sessions", totalSessions.toString());
      this.createStatCard(statsGrid, "Completed", `${completedSessions}/${totalSessions}`);
      this.createStatCard(statsGrid, "Total Words", totalWords.toLocaleString());
      this.createStatCard(statsGrid, "Total Time", this.formatDuration(totalTime));
      if (todaySessions.length > 0) {
        const todayWords = todaySessions.reduce((sum, s) => sum + s.wordsWritten, 0);
        this.createStatCard(statsGrid, "Today", `${todaySessions.length} sessions, ${todayWords} words`);
      }
    } else {
      statsContainer.createEl("p", {
        text: "No sessions yet. Start writing dangerously!",
        cls: "dangerous-writing-stats-empty"
      });
    }
    new import_obsidian.Setting(containerEl).setName("View all statistics").setDesc("See comprehensive writing history and detailed stats").addButton((btn) => btn.setButtonText("View All Stats").onClick(() => {
      this.plugin.openStatsView();
    }));
  }
};

// modal.ts
var import_obsidian2 = require("obsidian");
var SessionConfigModal = class extends import_obsidian2.Modal {
  constructor(app, defaultDuration, defaultWordCount, hasExistingContent, practiceMode, penaltyType, onSubmit) {
    super(app);
    this.result = null;
    this.onSubmit = onSubmit;
    this.durationMinutes = defaultDuration;
    this.wordCountGoal = defaultWordCount;
    this.useWordCount = defaultWordCount > 0;
    this.practiceMode = practiceMode;
    this.penaltyType = penaltyType;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("dw-modal");
    this.setTitle("Start Session");
    const penaltyText = this.penaltyType === "all" ? "everything" : this.penaltyType === "paragraph" ? "the last paragraph" : "the last sentence";
    if (this.practiceMode) {
      contentEl.createEl("p", {
        text: `Practice mode is ON \u2014 stopping will delete ${penaltyText}, but you can recover it.`,
        cls: "dangerous-writing-warning-text"
      });
    } else {
      contentEl.createEl("p", {
        text: `Not in practice mode \u2014 if you stop typing, you lose ${penaltyText}!`,
        cls: "dangerous-writing-warning-text"
      });
    }
    const seg = contentEl.createDiv({ cls: "dw-seg" });
    const minutesBtn = seg.createEl("button", {
      text: "Minutes",
      cls: "dw-seg-btn"
    });
    const wordsBtn = seg.createEl("button", {
      text: "Words",
      cls: "dw-seg-btn"
    });
    const picker = contentEl.createDiv({ cls: "dw-picker" });
    const setActiveChip = (wrap, value) => {
      wrap.querySelectorAll("button.dw-chip").forEach((b) => {
        const btn = b;
        btn.classList.toggle("is-active", btn.dataset.value === String(value));
      });
    };
    const CONFIG = {
      minutes: {
        presets: [5, 10, 15, 20, 30],
        unit: "min",
        get: () => this.durationMinutes || 5,
        set: (n) => this.durationMinutes = n
      },
      words: {
        presets: [100, 250, 500, 750, 1e3],
        unit: "words",
        get: () => this.wordCountGoal > 0 ? this.wordCountGoal : 500,
        set: (n) => this.wordCountGoal = n
      }
    };
    let inputEl = null;
    let chipsWrap = null;
    const renderPicker = (mode) => {
      minutesBtn.classList.toggle("is-active", mode === "minutes");
      wordsBtn.classList.toggle("is-active", mode === "words");
      picker.empty();
      chipsWrap = picker.createDiv({ cls: "dw-chips" });
      for (const preset of CONFIG[mode].presets) {
        const btn = chipsWrap.createEl("button", {
          text: String(preset),
          cls: "dw-chip"
        });
        btn.dataset.value = String(preset);
        btn.onclick = () => {
          CONFIG[mode].set(preset);
          if (inputEl)
            inputEl.value = String(preset);
          if (chipsWrap)
            setActiveChip(chipsWrap, preset);
        };
      }
      const row = picker.createDiv({ cls: "dw-input-row" });
      inputEl = row.createEl("input", {
        type: "text",
        cls: "dw-input",
        value: String(CONFIG[mode].get())
      });
      inputEl.setAttribute("inputmode", "numeric");
      inputEl.addEventListener("input", () => {
        const num = parseInt(inputEl.value);
        if (!isNaN(num) && num > 0) {
          CONFIG[mode].set(num);
          if (chipsWrap)
            setActiveChip(chipsWrap, num);
        }
      });
      row.createEl("span", { text: CONFIG[mode].unit, cls: "dw-unit" });
      setActiveChip(chipsWrap, CONFIG[mode].get());
    };
    const setMode = (mode) => {
      this.useWordCount = mode === "words";
      renderPicker(mode);
    };
    minutesBtn.onclick = () => setMode("minutes");
    wordsBtn.onclick = () => setMode("words");
    setMode(this.useWordCount ? "words" : "minutes");
    const btnRow = contentEl.createDiv({ cls: "dw-btn-row" });
    const cancelBtn = btnRow.createEl("button", {
      text: "Cancel",
      cls: "dw-btn"
    });
    cancelBtn.onclick = () => this.close();
    const startBtn = btnRow.createEl("button", {
      text: "Start",
      cls: "dw-btn dw-btn-cta"
    });
    startBtn.onclick = () => {
      if (this.useWordCount && this.wordCountGoal <= 0) {
        new import_obsidian2.Notice("Please enter a valid word count goal");
        return;
      }
      if (!this.useWordCount && this.durationMinutes <= 0) {
        new import_obsidian2.Notice("Please enter a valid duration");
        return;
      }
      this.result = {
        durationMinutes: this.useWordCount ? null : this.durationMinutes,
        wordCountGoal: this.useWordCount ? this.wordCountGoal : null
      };
      this.onSubmit(this.result);
      this.close();
    };
  }
  onClose() {
    this.contentEl.empty();
  }
};
var FirstTimeWarningModal = class extends import_obsidian2.Modal {
  constructor(app, onConfirm) {
    super(app);
    this.onConfirm = onConfirm;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    this.setTitle("\u26A0\uFE0F Dangerous Writing");
    contentEl.createEl("p", {
      text: "This plugin deletes content if you stop typing. Practice mode is ON by default.",
      cls: "dw-subtitle"
    });
    const list = contentEl.createEl("ul", { cls: "dw-warning-list" });
    list.createEl("li", { text: "Content is recoverable in practice mode" });
    list.createEl("li", { text: "Test in a safe vault first" });
    list.createEl("li", { text: "Switching files may end the session" });
    const btnRow = contentEl.createDiv({ cls: "dw-btn-row" });
    const cancelBtn = btnRow.createEl("button", {
      text: "Cancel",
      cls: "dw-btn"
    });
    cancelBtn.onclick = () => this.close();
    const confirmBtn = btnRow.createEl("button", {
      text: "I Understand",
      cls: "dw-btn dw-btn-cta"
    });
    confirmBtn.onclick = () => {
      this.onConfirm();
      this.close();
    };
  }
  onClose() {
    this.contentEl.empty();
  }
};

// stats.ts
var import_obsidian3 = require("obsidian");
var VIEW_TYPE_STATS = "dangerous-writing-stats";
var StatsView = class extends import_obsidian3.ItemView {
  constructor(leaf, sessions) {
    super(leaf);
    this.sessions = sessions;
  }
  getViewType() {
    return VIEW_TYPE_STATS;
  }
  getDisplayText() {
    return "Dangerous Writing Stats";
  }
  getIcon() {
    return "bar-chart-2";
  }
  updateSessions(sessions) {
    this.sessions = sessions;
    this.render();
  }
  async onOpen() {
    this.render();
  }
  render() {
    const container = this.containerEl.children[1];
    container.empty();
    container.createEl("h2", { text: "Dangerous Writing Statistics" });
    const now = Date.now();
    const day = 24 * 60 * 60 * 1e3;
    const week = 7 * day;
    const month = 30 * day;
    const periods = [
      { name: "Today", start: now - day },
      { name: "Past Week", start: now - week },
      { name: "Past Month", start: now - month },
      { name: "All Time", start: 0 }
    ];
    for (const period of periods) {
      const periodSessions = this.sessions.filter(
        (s) => s.timestamp >= period.start
      );
      this.renderPeriodStats(container, period.name, periodSessions);
    }
    container.createEl("h3", { text: "Recent Sessions" });
    if (this.sessions.length === 0) {
      container.createEl("p", {
        text: "No sessions yet. Start writing dangerously!",
        cls: "dangerous-writing-stats-empty"
      });
    } else {
      const recentSessions = this.sessions.slice(-10).reverse();
      const list = container.createEl("div", {
        cls: "dangerous-writing-sessions-list"
      });
      for (const session of recentSessions) {
        const item = list.createEl("div", {
          cls: "dangerous-writing-session-item"
        });
        const date = new Date(session.timestamp);
        const status = session.completed ? "\u2705" : "\u274C";
        const duration = this.formatDuration(session.durationSeconds);
        item.createEl("span", {
          text: `${status} ${date.toLocaleDateString()} ${date.toLocaleTimeString(
            [],
            { hour: "2-digit", minute: "2-digit" }
          )}`,
          cls: "session-date"
        });
        item.createEl("span", {
          text: `${session.wordsWritten} words`,
          cls: "session-words"
        });
        item.createEl("span", {
          text: duration,
          cls: "session-duration"
        });
      }
    }
  }
  renderPeriodStats(container, periodName, sessions) {
    const section = container.createEl("div", {
      cls: "dangerous-writing-stats-period"
    });
    section.createEl("h3", { text: periodName });
    const totalSessions = sessions.length;
    const completedSessions = sessions.filter((s) => s.completed).length;
    const totalWords = sessions.reduce((sum, s) => sum + s.wordsWritten, 0);
    const totalTime = sessions.reduce((sum, s) => sum + s.durationSeconds, 0);
    const statsGrid = section.createEl("div", {
      cls: "dangerous-writing-stats-grid"
    });
    this.createStatCard(statsGrid, "Sessions", totalSessions.toString());
    this.createStatCard(
      statsGrid,
      "Completed",
      `${completedSessions}/${totalSessions}`
    );
    this.createStatCard(
      statsGrid,
      "Words Written",
      totalWords.toLocaleString()
    );
    this.createStatCard(
      statsGrid,
      "Time Writing",
      this.formatDuration(totalTime)
    );
    if (totalSessions > 0) {
      const avgWords = Math.round(totalWords / totalSessions);
      const completionRate = Math.round(
        completedSessions / totalSessions * 100
      );
      this.createStatCard(statsGrid, "Avg Words/Session", avgWords.toString());
      this.createStatCard(statsGrid, "Completion Rate", `${completionRate}%`);
    }
  }
  createStatCard(container, label, value) {
    const card = container.createEl("div", {
      cls: "dangerous-writing-stat-card"
    });
    card.createEl("div", { text: value, cls: "stat-value" });
    card.createEl("div", { text: label, cls: "stat-label" });
  }
  formatDuration(seconds) {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor(seconds % 3600 / 60);
    const secs = seconds % 60;
    if (hours > 0) {
      return `${hours}h ${minutes}m`;
    } else if (minutes > 0) {
      return `${minutes}m ${secs}s`;
    } else {
      return `${secs}s`;
    }
  }
  async onClose() {
  }
};

// main.ts
var DangerousWritingPlugin = class extends import_obsidian4.Plugin {
  constructor() {
    super(...arguments);
    this.sessions = [];
    // Session state
    this.sessionActive = false;
    this.sessionStartTime = 0;
    this.sessionDurationMs = 0;
    this.wordCountGoal = null;
    this.initialWordCount = 0;
    this.activeFile = null;
    this.initialContent = "";
    this.sessionInterval = null;
    // Idle watchdog
    this.idleWatchdogTimeout = null;
    this.lastActivityTime = 0;
    this.warningOverlay = null;
    // Status bar
    this.statusBarEl = null;
    this.statusBarInterval = null;
    // Dynamic styles
    this.styleEl = null;
  }
  async onload() {
    await this.loadSettings();
    this.updateWarningStyles();
    this.registerView(
      VIEW_TYPE_STATS,
      (leaf) => new StatsView(leaf, this.sessions)
    );
    if (this.settings.showFirstTimeWarning) {
      new FirstTimeWarningModal(this.app, () => {
        this.settings.showFirstTimeWarning = false;
        this.saveSettings();
      }).open();
    }
    this.addRibbonIcon(
      "timer",
      "Start Dangerous Writing Session",
      (evt) => {
        this.startSession();
      }
    );
    this.addCommand({
      id: "start-dangerous-writing",
      name: "Start dangerous writing session",
      callback: () => {
        this.startSession();
      }
    });
    this.addCommand({
      id: "stop-dangerous-writing",
      name: "Stop dangerous writing session",
      checkCallback: (checking) => {
        if (checking) {
          return this.sessionActive;
        }
        if (this.sessionActive) {
          this.stopSession(true);
        }
        return true;
      }
    });
    this.addCommand({
      id: "open-dangerous-writing-stats",
      name: "Open writing statistics",
      callback: () => {
        this.openStatsView();
      }
    });
    this.registerEvent(
      this.app.workspace.on(
        "editor-change",
        (editor, info) => {
          if (this.sessionActive) {
            this.resetIdleWatchdog();
          }
        }
      )
    );
    this.registerEvent(
      this.app.workspace.on(
        "active-leaf-change",
        (leaf) => {
          if (this.sessionActive && leaf) {
            const view = leaf.view;
            if (view instanceof import_obsidian4.MarkdownView) {
              const currentFile = view.file;
              if (this.activeFile && currentFile && currentFile.path !== this.activeFile.path) {
                new import_obsidian4.Notice("Switched files during session - session ended");
                this.stopSession(false);
              }
            }
          }
        }
      )
    );
    this.addSettingTab(new DangerousWritingSettingTab(this.app, this));
    this.statusBarEl = this.addStatusBarItem();
    this.updateStatusBar();
  }
  onunload() {
    if (this.sessionActive) {
      this.stopSession(false);
    }
    this.cleanup();
    this.app.workspace.detachLeavesOfType(VIEW_TYPE_STATS);
  }
  async loadSettings() {
    const data = await this.loadData();
    this.settings = Object.assign({}, DEFAULT_SETTINGS, data == null ? void 0 : data.settings);
    this.sessions = (data == null ? void 0 : data.sessions) || [];
  }
  async saveSettings() {
    const data = {
      settings: this.settings,
      sessions: this.sessions
    };
    await this.saveData(data);
  }
  async openStatsView() {
    var _a;
    const existing = this.app.workspace.getLeavesOfType(VIEW_TYPE_STATS);
    if (existing.length) {
      this.app.workspace.revealLeaf(existing[0]);
      return;
    }
    await ((_a = this.app.workspace.getRightLeaf(false)) == null ? void 0 : _a.setViewState({
      type: VIEW_TYPE_STATS,
      active: true
    }));
  }
  updateWarningStyles() {
    if (this.styleEl) {
      this.styleEl.remove();
    }
    const color = this.settings.warningColor;
    const r = parseInt(color.slice(1, 3), 16);
    const g = parseInt(color.slice(3, 5), 16);
    const b = parseInt(color.slice(5, 7), 16);
    this.styleEl = document.createElement("style");
    this.styleEl.textContent = `
			.dangerous-writing-warning-overlay {
				transition: background-color 0.1s ease-out;
			}
		`;
    document.head.appendChild(this.styleEl);
  }
  recordSession(wordsWritten, durationSeconds, completed) {
    const record = {
      timestamp: Date.now(),
      durationSeconds,
      wordsWritten,
      completed
    };
    this.sessions.push(record);
    this.saveSettings();
    const leaves = this.app.workspace.getLeavesOfType(VIEW_TYPE_STATS);
    for (const leaf of leaves) {
      if (leaf.view instanceof StatsView) {
        leaf.view.updateSessions(this.sessions);
      }
    }
  }
  showClickableNotice(message, duration = 0) {
    const notice = new import_obsidian4.Notice(message, duration);
    const noticeEl = notice.noticeEl;
    if (noticeEl) {
      noticeEl.style.cursor = "pointer";
      noticeEl.addEventListener("click", () => {
        notice.hide();
      });
    }
    return notice;
  }
  startSession() {
    if (this.sessionActive) {
      new import_obsidian4.Notice("Session already active!");
      return;
    }
    const view = this.app.workspace.getActiveViewOfType(import_obsidian4.MarkdownView);
    if (!view) {
      new import_obsidian4.Notice("Please open a markdown file to start a session");
      return;
    }
    const file = view.file;
    if (!file) {
      new import_obsidian4.Notice("No file is open");
      return;
    }
    const editor = view.editor;
    const currentContent = editor.getValue();
    const hasExistingContent = currentContent.trim().length > 0;
    new SessionConfigModal(
      this.app,
      this.settings.sessionDurationMinutes,
      this.settings.defaultWordCountGoal,
      hasExistingContent,
      this.settings.practiceMode,
      this.settings.penaltyType,
      (config) => {
        this.beginSession(file, editor, config);
      }
    ).open();
  }
  beginSession(file, editor, config) {
    this.sessionActive = true;
    this.activeFile = file;
    this.initialContent = editor.getValue();
    this.initialWordCount = this.countWords(this.initialContent);
    this.sessionStartTime = Date.now();
    if (config.wordCountGoal !== null) {
      this.wordCountGoal = config.wordCountGoal;
      this.sessionDurationMs = 0;
    } else {
      this.wordCountGoal = null;
      this.sessionDurationMs = (config.durationMinutes || 5) * 60 * 1e3;
    }
    const intervalId = window.setInterval(() => {
      if (this.wordCountGoal !== null) {
        const currentWords = this.countWords(editor.getValue());
        if (currentWords - this.initialWordCount >= this.wordCountGoal) {
          this.completeSession();
        } else {
          this.updateStatusBar();
        }
      } else {
        const elapsed = Date.now() - this.sessionStartTime;
        if (elapsed >= this.sessionDurationMs) {
          this.completeSession();
        } else {
          this.updateStatusBar();
        }
      }
    }, 1e3);
    this.sessionInterval = intervalId;
    this.registerInterval(intervalId);
    this.resetIdleWatchdog();
    this.updateStatusBar();
    this.createWarningOverlay();
    if (this.wordCountGoal !== null) {
      new import_obsidian4.Notice(
        `Dangerous writing session started! Goal: ${this.wordCountGoal} words. Keep typing!`
      );
    } else {
      const minutes = Math.floor(this.sessionDurationMs / 6e4);
      new import_obsidian4.Notice(
        `Dangerous writing session started! ${minutes} minutes. Keep typing!`
      );
    }
  }
  resetIdleWatchdog() {
    if (this.idleWatchdogTimeout !== null) {
      window.clearTimeout(this.idleWatchdogTimeout);
      this.idleWatchdogTimeout = null;
    }
    this.lastActivityTime = Date.now();
    if (this.warningOverlay) {
      this.warningOverlay.className = "dangerous-writing-warning-overlay";
      this.warningOverlay.style.backgroundColor = "";
    }
    this.idleWatchdogTimeout = window.setTimeout(() => {
      this.triggerPenalty();
    }, this.settings.idleTimeoutSeconds * 1e3);
    this.startWarningInterval();
  }
  startWarningInterval() {
    const checkInterval = 50;
    const warningThreshold = this.settings.warningThresholdSeconds * 1e3;
    const color = this.settings.warningColor;
    const r = parseInt(color.slice(1, 3), 16);
    const g = parseInt(color.slice(3, 5), 16);
    const b = parseInt(color.slice(5, 7), 16);
    const warningCheck = window.setInterval(() => {
      if (!this.sessionActive) {
        window.clearInterval(warningCheck);
        return;
      }
      const idleTime = Date.now() - this.lastActivityTime;
      const remaining = this.settings.idleTimeoutSeconds * 1e3 - idleTime;
      if (remaining <= 0) {
        window.clearInterval(warningCheck);
        if (this.warningOverlay) {
          this.warningOverlay.style.backgroundColor = "";
        }
        return;
      }
      if (remaining <= warningThreshold && this.warningOverlay) {
        const progress = 1 - remaining / warningThreshold;
        const easedProgress = 1 - Math.pow(1 - progress, 3);
        const opacity = 0.05 + easedProgress * 0.55;
        this.warningOverlay.style.backgroundColor = `rgba(${r}, ${g}, ${b}, ${opacity})`;
      } else if (remaining > warningThreshold && this.warningOverlay) {
        this.warningOverlay.style.backgroundColor = "";
      }
    }, checkInterval);
  }
  applyPenalty(editor, content) {
    const penaltyType = this.settings.penaltyType;
    if (penaltyType === "all") {
      return "";
    }
    if (penaltyType === "sentence") {
      const sentenceEndings = /[.!?]\s*$/;
      let result = content.trimEnd();
      const lastSentenceMatch = result.match(/[.!?][^.!?]*$/);
      if (lastSentenceMatch) {
        result = result.slice(0, result.length - lastSentenceMatch[0].length);
      } else {
        const lines = result.split("\n");
        if (lines.length > 1) {
          lines.pop();
          result = lines.join("\n");
        } else {
          result = "";
        }
      }
      return result;
    }
    if (penaltyType === "paragraph") {
      const paragraphs = content.split(/\n\n+/);
      if (paragraphs.length > 1) {
        paragraphs.pop();
        return paragraphs.join("\n\n");
      }
      return "";
    }
    return "";
  }
  triggerPenalty() {
    if (!this.sessionActive) {
      return;
    }
    const view = this.app.workspace.getActiveViewOfType(import_obsidian4.MarkdownView);
    if (!view || view.file !== this.activeFile) {
      return;
    }
    const editor = view.editor;
    const currentContent = editor.getValue();
    const wordsWritten = this.countWords(currentContent);
    const durationSeconds = Math.floor(
      (Date.now() - this.sessionStartTime) / 1e3
    );
    const savedInitialContent = this.initialContent;
    const practiceMode = this.settings.practiceMode;
    const newContent = this.applyPenalty(editor, currentContent);
    editor.setValue(newContent);
    const penaltyTypeText = this.settings.penaltyType === "all" ? "All content" : this.settings.penaltyType === "paragraph" ? "Last paragraph" : "Last sentence";
    this.showClickableNotice(
      `\u26D4 You stopped writing! ${penaltyTypeText} deleted!`,
      0
    );
    this.recordSession(wordsWritten, durationSeconds, false);
    this.stopSession(false);
    if (practiceMode) {
      const recover = confirm(
        "Practice mode: Would you like to restore the original content?"
      );
      if (recover) {
        editor.setValue(savedInitialContent);
        new import_obsidian4.Notice("Content restored");
      }
    }
  }
  completeSession() {
    if (!this.sessionActive) {
      return;
    }
    const view = this.app.workspace.getActiveViewOfType(import_obsidian4.MarkdownView);
    if (!view || view.file !== this.activeFile) {
      this.stopSession(false);
      return;
    }
    const editor = view.editor;
    const wordsWritten = this.countWords(editor.getValue());
    const durationSeconds = Math.floor(
      (Date.now() - this.sessionStartTime) / 1e3
    );
    this.recordSession(wordsWritten, durationSeconds, true);
    this.stopSession(true);
    const minutes = Math.floor(durationSeconds / 60);
    const seconds = durationSeconds % 60;
    const durationStr = minutes > 0 ? `${minutes}m ${seconds}s` : `${seconds}s`;
    this.showClickableNotice(
      `\u{1F389} Session completed! ${wordsWritten} words in ${durationStr}. (click to close)`,
      0
    );
  }
  stopSession(completed) {
    if (!this.sessionActive) {
      return;
    }
    this.sessionActive = false;
    if (this.sessionInterval !== null) {
      window.clearInterval(this.sessionInterval);
      this.sessionInterval = null;
    }
    if (this.idleWatchdogTimeout !== null) {
      window.clearTimeout(this.idleWatchdogTimeout);
      this.idleWatchdogTimeout = null;
    }
    if (this.statusBarInterval !== null) {
      window.clearInterval(this.statusBarInterval);
      this.statusBarInterval = null;
    }
    this.removeWarningOverlay();
    this.activeFile = null;
    this.initialContent = "";
    this.initialWordCount = 0;
    this.wordCountGoal = null;
    this.lastActivityTime = 0;
    this.updateStatusBar();
  }
  createWarningOverlay() {
    if (this.warningOverlay) {
      return;
    }
    this.warningOverlay = document.createElement("div");
    this.warningOverlay.className = "dangerous-writing-warning-overlay";
    document.body.appendChild(this.warningOverlay);
  }
  removeWarningOverlay() {
    if (this.warningOverlay) {
      this.warningOverlay.remove();
      this.warningOverlay = null;
    }
  }
  updateStatusBar() {
    if (!this.statusBarEl) {
      return;
    }
    if (!this.sessionActive) {
      this.statusBarEl.setText("");
      this.statusBarEl.className = "";
      return;
    }
    const idleTime = Date.now() - this.lastActivityTime;
    const idleSeconds = Math.floor(idleTime / 1e3);
    const idleRemaining = Math.max(
      0,
      this.settings.idleTimeoutSeconds - idleSeconds
    );
    let statusText = "";
    if (this.wordCountGoal !== null) {
      const view = this.app.workspace.getActiveViewOfType(import_obsidian4.MarkdownView);
      if (view && view.file === this.activeFile) {
        const currentWords = this.countWords(view.editor.getValue());
        const wordsWritten = currentWords - this.initialWordCount;
        const remaining = Math.max(0, this.wordCountGoal - wordsWritten);
        statusText = `\u{1F4DD} ${wordsWritten}/${this.wordCountGoal} words`;
      } else {
        statusText = `\u{1F4DD} Goal: ${this.wordCountGoal} words`;
      }
    } else {
      const elapsed = Date.now() - this.sessionStartTime;
      const remaining = Math.max(0, this.sessionDurationMs - elapsed);
      const remainingMinutes = Math.floor(remaining / 6e4);
      const remainingSeconds = Math.floor(remaining % 6e4 / 1e3);
      statusText = `\u23F1\uFE0F ${remainingMinutes}:${String(remainingSeconds).padStart(
        2,
        "0"
      )}`;
    }
    if (idleRemaining <= this.settings.warningThresholdSeconds) {
      statusText += ` | \u26A0\uFE0F ${idleRemaining}s idle`;
      this.statusBarEl.className = "dangerous-writing-status-bar active warning";
    } else {
      statusText += ` | ${idleRemaining}s idle`;
      this.statusBarEl.className = "dangerous-writing-status-bar active";
    }
    this.statusBarEl.setText(statusText);
  }
  countWords(text) {
    return text.trim().split(/\s+/).filter((word) => word.length > 0).length;
  }
  cleanup() {
    this.removeWarningOverlay();
    if (this.statusBarEl) {
      this.statusBarEl.remove();
      this.statusBarEl = null;
    }
    if (this.styleEl) {
      this.styleEl.remove();
      this.styleEl = null;
    }
  }
};
